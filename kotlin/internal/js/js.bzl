# Copyright 2018 The Bazel Authors. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
load(
    "//kotlin/internal:defs.bzl",
    _KtJsInfo = "KtJsInfo",
    _TOOLCHAIN_TYPE = "TOOLCHAIN_TYPE",
)
load(
    "//kotlin/internal/js:impl.bzl",
    _kt_js_import_impl = "kt_js_import_impl",
    _kt_js_library_impl = "kt_js_library_impl",
)

kt_js_library = rule(
    attrs = {
        "srcs": attr.label_list(
            allow_empty = False,
            allow_files = [".kt"],
            mandatory = True,
        ),
        "deps": attr.label_list(
            doc = """A list of other kotlin JS libraries.""",
            allow_empty = True,
            providers = [_KtJsInfo],
        ),
        "module_kind": attr.string(
            doc = """The Kind of a module generated by compiler, users should stick to commonjs.""",
            default = "commonjs",
            values = ["umd", "commonjs", "amd", "plain"],
        ),
        "js_target": attr.string(
            default = "v5",
            values = ["v5"],
        ),
        "module_root": attr.string(
            doc = "internal attriubte",
            mandatory = False,
        ),
        "module_name": attr.string(
            doc = "internal attribute",
            mandatory = False,
        ),
    },
    implementation = _kt_js_library_impl,
    outputs = dict(
        js = "%{name}.js",
        js_map = "%{name}.js.map",
        jar = "%{name}.jar",
        srcjar = "%{name}-sources.jar",
    ),
    toolchains = [_TOOLCHAIN_TYPE],
    provides = [_KtJsInfo],
)

# The macro exists to ensure compatibility with the nodejs rules, the nodejs rules process the attributes and not the
# providers. Ideally providers would be used so the rules can pass the information along without having to have user
# facing attributes visible.
#   module_root: if the module_root is made settable then there is a possibility of collisions. Keeping it simple here.
#   module_name: The require statement generated by Kotlinc-js seems to be based on the name of the jar. Unlike the jvm
#       compiler, there is no 'module-name' flag available. So to keep things simple it's hard coded to the module name.
def kt_js_library_macro(name, **kwargs):
    if kwargs.get("module_root") != None:
        fail("The module_root is an internal attribute.")
    else:
        kwargs["module_root"] = name + ".js"

    if kwargs.get("module_name") != None:
        fail("module_name is an internal attribute.")
    else:
        kwargs["module_name"] = name
    kt_js_library(name = name, **kwargs)

# TODO for Node the kotlin dependencies have to be provided via node_modules. The correct approach is to unpack the
# the jars and make the js and js.map files available to node (via the module_root and module_name attributes?).
kt_js_import = rule(
    attrs = {
        "jars": attr.label_list(
            allow_files = [".jar"],
            mandatory = True,
        ),
        "srcjar": attr.label(
            allow_files = ["-sources.jar"],
            mandatory = False,
            single_file = True,
        ),
        "runtime_deps": attr.label_list(
            default = [],
            allow_files = [".jar"],
            mandatory = False,
        ),
    },
    implementation = _kt_js_import_impl,
    provides = [_KtJsInfo],
)
